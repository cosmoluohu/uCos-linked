#include "timer.h"
#include "usart6.h"	
#include "includes.h"	 	//ucos 使用	 

void TIM1_PWM_Init(u16 arr,u16 psc)//E9E11  E13E14
{
	RCC->APB2ENR|=1<<0;   	//TIM1时钟使能 
	RCC->AHB1ENR|=1<<4;   	//使能PORTE时钟	
	GPIO_Set(GPIOE,PIN9|PIN11|PIN13|PIN14,GPIO_MODE_AF,GPIO_OTYPE_PP,GPIO_SPEED_100M,GPIO_PUPD_PU);//E5,6,复用功能,上拉
	GPIO_AF_Set(GPIOE,9, 1);	//PA3,AF1
	GPIO_AF_Set(GPIOE,11,1);	//PA3,AF1
	GPIO_AF_Set(GPIOE,13,1);	//PA3,AF1
	GPIO_AF_Set(GPIOE,14,1);	//PA3,AF1
		
 	TIM1->ARR=arr;  		//设定计数器自动重装值   
	TIM1->PSC=psc;  		//预分频器 
	
	TIM1->CCMR1|=6<<4;  	//CH1 PWM1模式		 
	TIM1->CCMR1|=1<<3; 	  //CH1 预装载使能
	TIM1->CCMR1|=6<<12;  	//CH2 PWM1模式		 
	TIM1->CCMR1|=1<<11; 	//CH2 预装载使能
	TIM1->CCMR2|=6<<4;  	//CH3 PWM1模式		 
	TIM1->CCMR2|=1<<3; 	  //CH3 预装载使能
	TIM1->CCMR2|=6<<12;  	//CH4 PWM1模式		 
	TIM1->CCMR2|=1<<11; 	//CH4 预装载使能
		
	TIM1->CCER|=1<<0;   	//OC1 输出使能
	TIM1->CCER|=1<<1;   	//OC1 HIGH polar
	TIM1->CCER|=1<<4;   	//OC2 输出使能	  
	TIM1->CCER|=1<<5;   	//OC2 HIGH polar	
	TIM1->CCER|=1<<8;   	//OC3 输出使能
	TIM1->CCER|=1<<9;   	//OC3 HIGH polar
	TIM1->CCER|=1<<12;   	//OC4 输出使能	  
	TIM1->CCER|=1<<13;   	//OC4 HIGH polar
	
	TIM1->CR1|=1<<7;   		//ARPE Auto-reload preload enable
	TIM1->CR1|=1<<0;    	//使能 	
	
	TIM1->BDTR|=((uint16_t)0x8000);//TIM1&TIM8 break and dead-time register
	
}


void TIM10_PWM_Init(u32 arr,u32 psc) //F6
{
	RCC->APB2ENR|=1<<17; 	//TIM10时钟使能    
	RCC->AHB1ENR|=1<<5;   	//使能PORTF时钟	
	GPIO_Set(GPIOF,PIN6,GPIO_MODE_AF,GPIO_OTYPE_PP,GPIO_SPEED_100M,GPIO_PUPD_PU);//复用功能,上拉输出
	GPIO_AF_Set(GPIOF,6,3);	//PF6,AF3 
	
	TIM10->ARR=arr;			//设定计数器自动重装值 
	TIM10->PSC=psc;			//预分频器不分频 
	TIM10->CCMR1|=6<<4;  	//CH1 PWM1模式		 
	TIM10->CCMR1|=1<<3; 	//CH1 预装载使能	   //???????????
	TIM10->CCER|=1<<0;   	//OC1 输出使能	
	TIM10->CCER|=1<<1;   	//OC1 High polar 1: OC1 active low	   
	TIM10->CR1|=1<<7;   	//ARPE使能 
	TIM10->CR1|=1<<0;    	//使能定时器10 				
}
void TIM11_PWM_Init(u32 arr,u32 psc) //F7
{
	RCC->APB2ENR|=1<<18; 	//TIM11时钟使能    
	RCC->AHB1ENR|=1<<5;   	//使能PORTF时钟	
	GPIO_Set(GPIOF,PIN7,GPIO_MODE_AF,GPIO_OTYPE_PP,GPIO_SPEED_100M,GPIO_PUPD_PU);//复用功能,上拉输出
	GPIO_AF_Set(GPIOF,7,3);	//PF7,AF3 
	
	TIM11->ARR=arr;			//设定计数器自动重装值 
	TIM11->PSC=psc;			//预分频器不分频 
	TIM11->CCMR1|=6<<4;  	//CH1 PWM1模式		 
	TIM11->CCMR1|=1<<3; 	//CH1 预装载使能	   //???????????
	TIM11->CCER|=1<<0;   	//OC1 输出使能	
	TIM11->CCER|=1<<1;   	//OC1 High polar 1: OC1 active low	   
	TIM11->CR1|=1<<7;   	//ARPE使能 
	TIM11->CR1|=1<<0;    	//使能定时器11 				
}



//定时器3中断服务程序	 
//void TIM3_IRQHandler(void)
//{ 		    		  			    
//	if(TIM3->SR&0X0001)//溢出中断
//	{
//	//	printf("frame:%d\r\n",ov_frame);//打印帧率
//	//	printf("jpeg_data_len:%d\r\n",jpeg_data_len*4);//打印帧率
//		ov_frame=0;
//	}				   
//	TIM3->SR&=~(1<<0);//清除中断标志位 	    
//}
//通用定时器3中断初始化
//这里时钟选择为APB1的2倍，而APB1为42M
//arr：自动重装值。
//psc：时钟预分频数
//定时器溢出时间计算方法:Tout=((arr+1)*(psc+1))/Ft us.
//Ft=定时器工作频率,单位:Mhz
//这里使用的是定时器3!
//void TIM3_Int_Init(u16 arr,u16 psc)
//{
//	RCC->APB1ENR|=1<<1;	//TIM3时钟使能    
// 	TIM3->ARR=arr;  	//设定计数器自动重装值 
//	TIM3->PSC=psc;  	//预分频器	  
//	TIM3->DIER|=1<<0;   //允许更新中断	  
//	TIM3->CR1|=0x01;    //使能定时器3
//  MY_NVIC_Init(1,3,TIM3_IRQn,2);	//抢占1，子优先级3，组2									 
//}




//TIM13,14 PWM部分初始化 
//PWM输出初始化
//arr：自动重装值
//psc：时钟预分频数
void TIM13_PWM_Init(u32 arr,u32 psc) //F8
{
  RCC->APB1ENR|=1<<7; 	//TIM13时钟使能    
	RCC->AHB1ENR|=1<<5;   	//使能PORTF时钟	
	GPIO_Set(GPIOF,PIN8,GPIO_MODE_AF,GPIO_OTYPE_PP,GPIO_SPEED_100M,GPIO_PUPD_PU);//复用功能,上拉输出
	GPIO_AF_Set(GPIOF,8,9);	//PF8,AF9 
	
	TIM13->ARR=arr;			//设定计数器自动重装值 
	TIM13->PSC=psc;			//预分频器不分频 
	TIM13->CCMR1|=6<<4;  	//CH1 PWM1模式		 
	TIM13->CCMR1|=1<<3; 	//CH1 预装载使能	   //???????????
	TIM13->CCER|=1<<0;   	//OC1 输出使能	
	TIM13->CCER|=1<<1;   	//OC1 High polar 1: OC1 active low	   
	TIM13->CR1|=1<<7;   	//ARPE使能 
	TIM13->CR1|=1<<0;    	//使能定时器14 				
}
void TIM14_PWM_Init(u32 arr,u32 psc)   //F9
{		 					 
	RCC->APB1ENR|=1<<8; 	//TIM14时钟使能    
	RCC->AHB1ENR|=1<<5;   	//使能PORTF时钟	
	GPIO_Set(GPIOF,PIN9,GPIO_MODE_AF,GPIO_OTYPE_PP,GPIO_SPEED_100M,GPIO_PUPD_PU);//复用功能,上拉输出
	GPIO_AF_Set(GPIOF,9,9);	//PF9,AF9 
	
	TIM14->ARR=arr;			//设定计数器自动重装值 
	TIM14->PSC=psc;			//预分频器不分频 
	TIM14->CCMR1|=6<<4;  	//CH1 PWM1模式		 
	TIM14->CCMR1|=1<<3; 	//CH1 预装载使能	
	TIM14->CCER|=1<<0;   	//OC1 输出使能	
	TIM14->CCER|=1<<1;   	//OC1 High polar default; 1: OC1 active low	   
	TIM14->CR1|=1<<7;   	//ARPE使能 
	TIM14->CR1|=1<<0;    	//使能定时器14	
}  


void TIM9_PWM_Init(u16 arr,u16 psc)  //E5 E6
{		 					 
	RCC->APB2ENR|=1<<16;   	//TIM9时钟使能 
	RCC->AHB1ENR|=1<<4;   	//使能PORTE时钟	
	GPIO_Set(GPIOE,PIN5|PIN6,GPIO_MODE_AF,GPIO_OTYPE_PP,GPIO_SPEED_100M,GPIO_PUPD_PU);//E5,6,复用功能,上拉
	GPIO_AF_Set(GPIOE,5,3);	//PA3,AF3
	GPIO_AF_Set(GPIOE,6,3);	//PA3,AF3
 	TIM9->ARR=arr;  		//设定计数器自动重装值   
	TIM9->PSC=psc;  		//预分频器 
	TIM9->CCMR1|=6<<4;  	//CH1 PWM1模式		 
	TIM9->CCMR1|=1<<3; 	  //CH1 预装载使能
	TIM9->CCMR1|=6<<12;  	//CH2 PWM1模式		 
	TIM9->CCMR1|=1<<11; 	//CH2 预装载使能
	
	TIM9->CCER|=1<<0;   	//OC1 输出使能
	TIM9->CCER|=1<<1;   	//OC1 HIGH polar
	TIM9->CCER|=1<<4;   	//OC2 输出使能	  
	TIM9->CCER|=1<<5;   	//OC2 HIGH polar	
	TIM9->CR1|=1<<7;   		//ARPE
	TIM9->CR1|=1<<0;    	//使能 
	} 



//定时器2通道1输入捕获配置
//arr：自动重装值(TIM2,TIM5是32位的!!)
//psc：时钟预分频数
//void TIM5_CH1_Cap_Init(u32 arr,u16 psc)
//{		 
//	RCC->APB1ENR|=1<<3;   	//TIM5 时钟使能 
//	RCC->AHB1ENR|=1<<0;   	//使能PORTA时钟	
//	GPIO_Set(GPIOA,PIN0,GPIO_MODE_AF,GPIO_OTYPE_PP,GPIO_SPEED_100M,GPIO_PUPD_PD);//复用功能,下拉
//	GPIO_AF_Set(GPIOA,0,2);	//PA0,AF2
//	  
// 	TIM5->ARR=arr;  		//设定计数器自动重装值   
//	TIM5->PSC=psc;  		//预分频器 

//	TIM5->CCMR1|=1<<0;		//CC1S=01 	选择输入端 IC1映射到TI1上
// 	TIM5->CCMR1|=0<<4; 		//IC1F=0000 配置输入滤波器 不滤波
// 	TIM5->CCMR1|=0<<10; 	//IC2PS=00 	配置输入分频,不分频 

//	TIM5->CCER|=0<<1; 		//CC1P=0	上升沿捕获
//	TIM5->CCER|=1<<0; 		//CC1E=1 	允许捕获计数器的值到捕获寄存器中

//	TIM5->EGR=1<<0;			//软件控制产生更新事件,使写入PSC的值立即生效,否则将会要等到定时器溢出才会生效!
//	TIM5->DIER|=1<<1;   	//允许捕获1中断				
//	TIM5->DIER|=1<<0;   	//允许更新中断	
//	TIM5->CR1|=0x01;    	//使能定时器2
//	MY_NVIC_Init(2,0,TIM5_IRQn,2);//抢占2，子优先级0，组2	   
//}
//捕获状态
//[7]:0,没有成功的捕获;1,成功捕获到一次.
//[6]:0,还没捕获到低电平;1,已经捕获到低电平了.
//[5:0]:捕获低电平后溢出的次数(对于32位定时器来说,1us计数器加1,溢出时间:4294秒)
//u8  TIM5CH1_CAPTURE_STA=0;	//输入捕获状态		    				
//u32	TIM5CH1_CAPTURE_VAL;	//输入捕获值(TIM2/TIM5是32位)
////定时器5中断服务程序	 
//void TIM5_IRQHandler(void)
//{ 		    
//	u16 tsr;
//	tsr=TIM5->SR;
// 	if((TIM5CH1_CAPTURE_STA&0X80)==0)//还未成功捕获	
//	{
//		if(tsr&0X01)//溢出
//		{	     
//			if(TIM5CH1_CAPTURE_STA&0X40)//已经捕获到高电平了
//			{
//				if((TIM5CH1_CAPTURE_STA&0X3F)==0X3F)//高电平太长了
//				{
//					TIM5CH1_CAPTURE_STA|=0X80;		//标记成功捕获了一次
//					TIM5CH1_CAPTURE_VAL=0XFFFFFFFF;
//				}else TIM5CH1_CAPTURE_STA++;
//			}	 
//		}
//		if(tsr&0x02)//捕获1发生捕获事件
//		{	
//			if(TIM5CH1_CAPTURE_STA&0X40)		//捕获到一个下降沿 		
//			{	  			
//				TIM5CH1_CAPTURE_STA|=0X80;		//标记成功捕获到一次高电平脉宽
//			    TIM5CH1_CAPTURE_VAL=TIM5->CCR1;	//获取当前的捕获值.
//	 			TIM5->CCER&=~(1<<1);			//CC1P=0 设置为上升沿捕获
//			}else  								//还未开始,第一次捕获上升沿
//			{
//				TIM5CH1_CAPTURE_STA=0;			//清空
//				TIM5CH1_CAPTURE_VAL=0;
//				TIM5CH1_CAPTURE_STA|=0X40;		//标记捕获到了上升沿
//				TIM5->CR1&=~(1<<0)		;    	//使能定时器2
//	 			TIM5->CNT=0;					//计数器清空
//	 			TIM5->CCER|=1<<1; 				//CC1P=1 设置为下降沿捕获
//				TIM5->CR1|=0x01;    			//使能定时器2
//			}		    
//		}			     	    					   
// 	}
//	TIM5->SR=0;//清除中断标志位   
//}


////////////////Peltier//////////////////////////////////////////////////////
void	TIM5_PWM_Init(u32 arr,u32 psc)  //PA2A3 Tx2Rx2  //TIM2 CH3,4 从A2,A3改到B10,B11的TIM2的CH3,4.
{                                     //这里不能使用TIM2 CH3,4 需要给成别的定时器比如TIM5
	RCC->APB1ENR|=1<<3;   	//TIM5时钟使能 
	RCC->AHB1ENR|=1<<0;   	//使能PORTA时钟	
	GPIO_Set(GPIOA,PIN1|PIN2|PIN3,GPIO_MODE_AF,GPIO_OTYPE_PP,GPIO_SPEED_100M,GPIO_PUPD_PU);//A2,3,复用功能,上拉PA1
	GPIO_AF_Set(GPIOA,1,2);	//PA1,AF2:TIM5
	GPIO_AF_Set(GPIOA,2,2);	//PA2,AF2
	GPIO_AF_Set(GPIOA,3,2);	//PA3,AF2
 	TIM5->ARR=arr;  		//设定计数器自动重装值   
	TIM5->PSC=psc;  		//预分频器 

//	TIM5->CCMR1|=6<<4;  	//CH1 PWM1模式		 
//	TIM5->CCMR1|=1<<3; 	  //CH1 预装载使能
	TIM5->CCMR1|=6<<12;  	//CH2 PWM1模式		 
	TIM5->CCMR1|=1<<11; 	//CH2 预装载使能

	TIM5->CCMR2|=6<<4;  	//CH3 PWM1模式		 
	TIM5->CCMR2|=1<<3; 	  //CH3 预装载使能
	TIM5->CCMR2|=6<<12;  	//CH4 PWM1模式		 
	TIM5->CCMR2|=1<<11; 	//CH4 预装载使能

//	TIM5->CCER|=1<<0;   	//OC1 输出使能
//	TIM5->CCER|=0<<1;   	//OC1 HIGH polar
	TIM5->CCER|=1<<4;   	//OC2 输出使能	  
	TIM5->CCER|=0<<5;   	//OC2 HIGH polar	
	
	TIM5->CCER|=1<<8;   	//OC3 输出使能
	TIM5->CCER|=0<<9;   	//OC3 HIGH polar
	TIM5->CCER|=1<<12;   	//OC4 输出使能	  
	TIM5->CCER|=0<<13;   	//OC4 HIGH polar	
	
	TIM5->CR1|=1<<7;   		//ARPE
	TIM5->CR1|=1<<0;    	//使能 
}

////////////////Stretch//////////////////////////////////////////////////////
void	TIM2_PWM_Init(u32 arr,u32 psc)  //PA2A3 Tx2Rx2  //TIM2 CH3,4 从A2,A3改到B10,B11的TIM2的CH3,4.
{
	RCC->APB1ENR|=1<<0;   	//TIM2时钟使能 
	RCC->AHB1ENR|=1<<1;   	//使能PORTA时钟	这里需要改成B口
	GPIO_Set(GPIOB,PIN10|PIN11,GPIO_MODE_AF,GPIO_OTYPE_PP,GPIO_SPEED_100M,GPIO_PUPD_PU);//A2,3,复用功能,上拉
	GPIO_AF_Set(GPIOB,10,1);	//PB2,AF1
	GPIO_AF_Set(GPIOB,11,1);	//PB3,AF1
 	TIM2->ARR=arr;  		//设定计数器自动重装值   
	TIM2->PSC=psc;  		//预分频器 
	TIM2->CCMR2|=6<<4;  	//CH3 PWM1模式		 
	TIM2->CCMR2|=1<<3; 	  //CH3 预装载使能
	TIM2->CCMR2|=6<<12;  	//CH4 PWM1模式		 
	TIM2->CCMR2|=1<<11; 	//CH4 预装载使能
	
	TIM2->CCER|=1<<8;   	//OC3 输出使能
	TIM2->CCER|=0<<9;   	//OC3 HIGH polar
	TIM2->CCER|=1<<12;   	//OC2 输出使能	  
	TIM2->CCER|=0<<13;   	//OC2 HIGH polar	
	TIM2->CR1|=1<<7;   		//ARPE
	TIM2->CR1|=1<<0;    	//使能 
}




extern vu16 USART6_RX_STA;

//定时器7中断服务程序		    
void TIM7_IRQHandler(void)
{ 	
	OSIntEnter();    		    
	if(TIM7->SR&0X01)//是更新中断
	{	 			   
		USART6_RX_STA|=1<<15;	//标记接收完成
		TIM7->SR&=~(1<<0);		//清除中断标志位		   
		TIM7->CR1&=~(1<<0);		//关闭定时器7	  
	}	    
	OSIntExit();  											 
} 
//通用定时器7中断初始化
//这里时钟选择为APB1的2倍，而APB1为42M
//arr：自动重装值。
//psc：时钟预分频数
//定时器溢出时间计算方法:Tout=((arr+1)*(psc+1))/Ft us.
//Ft=定时器工作频率,单位:Mhz 
void TIM7_Int_Init(u16 arr,u16 psc)
{
	RCC->APB1ENR|=1<<5;	//TIM7时钟使能    
 	TIM7->ARR=arr;  	//设定计数器自动重装值 
	TIM7->PSC=psc;  	//预分频器	  
	TIM7->CNT=0;  		//计数器清零	  
	TIM7->DIER|=1<<0;   //允许更新中断	  
	TIM7->CR1|=0x01;    //使能定时器7
  	MY_NVIC_Init(0,1,TIM7_IRQn,2);	//抢占0，子优先级1，组2									 
} 














